<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a1a">
<title>Traduttore</title>
<style>
:root {
  --bg: #0a0a1a;
  --border: rgba(255,255,255,0.12);
  --text: #f0f0ff;
  --muted: rgba(240,240,255,0.30);
  --blue: #4f9fff;
  --red: #ff5f7e;
  --cyan: #4ff0d0;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body {
  width: 100%; height: 100%; overflow: hidden;
  -webkit-text-size-adjust: none;
  background: var(--bg); color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
  -webkit-font-smoothing: antialiased;
}
#app {
  position: fixed;
  top: env(safe-area-inset-top, 0px);
  left: 0; right: 0;
  bottom: env(safe-area-inset-bottom, 0px);
  display: flex; flex-direction: column;
  background:
    radial-gradient(ellipse 80% 60% at 20% 10%, rgba(79,159,255,0.12) 0%, transparent 60%),
    radial-gradient(ellipse 60% 50% at 80% 90%, rgba(79,240,208,0.09) 0%, transparent 60%),
    var(--bg);
}
.half {
  flex: 1; min-height: 0;
  display: flex; flex-direction: column;
  align-items: center; justify-content: space-evenly;
  padding: 10px 20px;
}
.half.top { transform: rotate(180deg); border-bottom: 1px solid var(--border); }
.div {
  flex: 0 0 26px;
  display: flex; align-items: center; justify-content: center; gap: 18px;
  border-top: 1px solid var(--border); border-bottom: 1px solid var(--border);
  background: rgba(255,255,255,0.012);
}
.div svg { width: 15px; height: 15px; color: var(--muted); }
.sel {
  width: 100%; max-width: 280px;
  background: rgba(255,255,255,0.08); border: 1px solid var(--border);
  border-radius: 50px; color: var(--text);
  font-size: 15px; font-weight: 600; padding: 9px 18px;
  text-align: center; outline: none; -webkit-appearance: none; cursor: pointer; flex-shrink: 0;
}
.sel option { background: #1a1a30; }
.txt {
  width: 100%; max-width: 320px; height: 80px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  text-align: center; font-size: 19px; line-height: 1.4;
  border-radius: 12px; border: 1px solid transparent;
  padding: 8px 12px; overflow-y: auto;
  transition: background .2s, border-color .2s;
}
.txt.ph  { color: var(--muted); font-style: italic; font-size: 13px; }
.txt.on  { background: rgba(79,159,255,0.09); border-color: rgba(79,159,255,0.4); }
.txt.say { background: rgba(79,240,208,0.09); border-color: rgba(79,240,208,0.4); }
.st { font-size: 12px; color: var(--cyan); display: flex; align-items: center; gap: 5px; height: 16px; flex-shrink: 0; }
@keyframes sp { to { transform: rotate(360deg); } }
.spin { width: 12px; height: 12px; flex-shrink: 0; border: 2px solid rgba(79,240,208,0.2); border-top-color: var(--cyan); border-radius: 50%; animation: sp .7s linear infinite; }
.mic {
  width: 94px; height: 94px; border-radius: 50%; border: none; background: transparent;
  cursor: pointer; position: relative; display: flex; align-items: center; justify-content: center;
  -webkit-tap-highlight-color: transparent; touch-action: manipulation; flex-shrink: 0;
}
.mic:active { opacity: .8; }
.face {
  position: absolute; inset: 0; border-radius: 50%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  gap: 4px; font-size: 12px; font-weight: 700; color: #fff; pointer-events: none;
}
.face svg { width: 30px; height: 30px; }
.mic.blu .face { background: linear-gradient(135deg,#4f9fff,#1e58cc); box-shadow: 0 5px 22px rgba(79,159,255,0.5),inset 0 0 0 1px rgba(255,255,255,0.14); }
.mic.red .face { background: linear-gradient(135deg,#ff5f7e,#a01e3c); box-shadow: 0 5px 22px rgba(255,95,126,0.5),inset 0 0 0 1px rgba(255,255,255,0.14); }
.rsvg { position: absolute; inset: -7px; width: calc(100% + 14px); height: calc(100% + 14px); pointer-events: none; transform: rotate(-90deg); }
.rb { fill: none; stroke: rgba(255,255,255,0.07); stroke-width: 3; }
.rf { fill: none; stroke-width: 3; stroke-linecap: round; transition: stroke-dashoffset .1s; }
.mic.blu .rf { stroke: var(--blue); } .mic.red .rf { stroke: var(--red); }
@keyframes pr { 0%{transform:scale(1);opacity:.55} 100%{transform:scale(1.9);opacity:0} }
.mic.rec::after { content:''; position:absolute; inset:-7px; border-radius:50%; border:2.5px solid currentColor; animation:pr 1.1s ease-out infinite; }
.mic.blu.rec { color: var(--blue); } .mic.red.rec { color: var(--red); }
@keyframes ps { 0%{transform:scale(1);opacity:.45} 100%{transform:scale(2.1);opacity:0} }
.mic.tts::after { content:''; position:absolute; inset:-7px; border-radius:50%; border:2.5px solid var(--cyan); animation:ps .9s ease-out infinite; }
.tmr { font-size: 11px; font-weight: 700; color: var(--muted); height: 14px; flex-shrink: 0; }
#toast {
  position: fixed; bottom: calc(10px + env(safe-area-inset-bottom,0px));
  left: 50%; transform: translateX(-50%) translateY(12px);
  background: rgba(16,16,36,.97); border: 1px solid rgba(255,255,255,.22);
  border-radius: 50px; padding: 9px 20px; font-size: 13px; font-weight: 600; color: var(--text);
  z-index: 999; opacity: 0; transition: opacity .22s, transform .22s; pointer-events: none;
  backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
  white-space: nowrap; max-width: 90vw; text-align: center;
}
#toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
</style>
</head>
<body>
<div id="app">

  <!-- INTERLOCUTORE (ruotato 180Â°) -->
  <div class="half top">
    <select class="sel" id="lb" onchange="onLC('b')">
      <option value="en">ğŸ‡¬ğŸ‡§ English</option>
      <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
      <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
      <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
      <option value="pt">ğŸ‡µğŸ‡¹ PortuguÃªs</option>
      <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
      <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
      <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
      <option value="bg">ğŸ‡§ğŸ‡¬ Ğ‘ÑŠĞ»Ğ³Ğ°Ñ€ÑĞºĞ¸</option>
      <option value="cs">ğŸ‡¨ğŸ‡¿ ÄŒeÅ¡tina</option>
    </select>
    <div class="txt ph" id="tb">â€¦</div>
    <div class="st" id="sb"></div>
    <div class="tmr" id="mb"></div>
    <button class="mic red" id="bb" onclick="tap('b')">
      <svg class="rsvg" viewBox="0 0 108 108"><circle class="rb" cx="54" cy="54" r="50"/><circle class="rf" id="rb" cx="54" cy="54" r="50" stroke-dasharray="314" stroke-dashoffset="314"/></svg>
      <div class="face">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2M12 19v4M8 23h8"/></svg>
        <span id="nlb">Speak</span>
      </div>
    </button>
  </div>

  <div class="div">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16V4m0 0L3 8m4-4l4 4"/><path d="M17 8v12m0 0l4-4m-4 4l-4-4"/></svg>
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16V4m0 0L3 8m4-4l4 4"/><path d="M17 8v12m0 0l4-4m-4 4l-4-4"/></svg>
  </div>

  <!-- IO -->
  <div class="half">
    <select class="sel" id="la" onchange="onLC('a')">
      <option value="it" selected>ğŸ‡®ğŸ‡¹ Italiano</option>
      <option value="en">ğŸ‡¬ğŸ‡§ English</option>
      <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
      <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
      <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
      <option value="pt">ğŸ‡µğŸ‡¹ PortuguÃªs</option>
      <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
      <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
      <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
      <option value="bg">ğŸ‡§ğŸ‡¬ Ğ‘ÑŠĞ»Ğ³Ğ°Ñ€ÑĞºĞ¸</option>
      <option value="cs">ğŸ‡¨ğŸ‡¿ ÄŒeÅ¡tina</option>
    </select>
    <div class="txt ph" id="ta">â€¦</div>
    <div class="st" id="sa"></div>
    <div class="tmr" id="ma"></div>
    <button class="mic blu" id="ba" onclick="tap('a')">
      <svg class="rsvg" viewBox="0 0 108 108"><circle class="rb" cx="54" cy="54" r="50"/><circle class="rf" id="ra" cx="54" cy="54" r="50" stroke-dasharray="314" stroke-dashoffset="314"/></svg>
      <div class="face">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2M12 19v4M8 23h8"/></svg>
        <span id="nla">Parla</span>
      </div>
    </button>
  </div>

</div>
<div id="toast"></div>

<script>
'use strict';
/*
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  SOLUZIONE iOS TTS (fonte: talkrapp.com/speechSynthesis.html)

  "SpeechRecognition events count as a user-initiated event"

  Quindi speak() va chiamato DENTRO rec.onend / rec.onresult,
  NON dopo un await asincrono.

  STRATEGIA:
  1. rec.onend scatta â†’ iOS lo considera evento utente valido
  2. Dentro onend: chiamo speak() SUBITO con il testo ancora
     da tradurre (o giÃ  tradotto se era veloce)
  3. Lancio la traduzione in parallelo in onresult (appena
     arriva il testo finale) cosÃ¬ Ã¨ giÃ  pronta quando serve

  NOTA IMPORTANTE: assicurarsi che il telefono NON sia in
  modalitÃ  silenziosa (interruttore fisico laterale su iPhone)!
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
*/

const BCP = {it:'it-IT',en:'en-US',es:'es-ES',fr:'fr-FR',de:'de-DE',pt:'pt-PT',ru:'ru-RU',zh:'zh-CN',ar:'ar-SA',bg:'bg-BG',cs:'cs-CZ'};
const LBL = {it:'Parla',en:'Speak',es:'Hablar',fr:'Parler',de:'Sprechen',pt:'Falar',ru:'Ğ“Ğ¾Ğ²Ğ¾Ñ€Ğ¸Ñ‚ÑŒ',zh:'è¯´è¯',ar:'ØªÙƒÙ„Ù…',bg:'Ğ“Ğ¾Ğ²Ğ¾Ñ€Ğ¸',cs:'Mluvit'};

const $  = id => document.getElementById(id);
const ga = () => $('la').value;
const gb = () => $('lb').value;
const gl = s  => s === 'a' ? ga() : gb();

function onLC(s) { $('nl'+(s==='a'?'a':'b')).textContent = LBL[gl(s)]||'Speak'; }

let toastT;
function toast(m, ms=2600){ const e=$('toast'); e.textContent=m; e.classList.add('show'); clearTimeout(toastT); toastT=setTimeout(()=>e.classList.remove('show'),ms); }

// â”€â”€ Voci â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Su iOS getVoices() ritorna lista solo dopo onvoiceschanged
let _voices = [];
function loadVoices(){
  if(!window.speechSynthesis) return;
  const v = speechSynthesis.getVoices();
  if(v.length){ _voices = v; return; }
  speechSynthesis.onvoiceschanged = () => { _voices = speechSynthesis.getVoices(); };
}
function getVoice(lang){
  const bcp = BCP[lang]||'en-US';
  const px  = bcp.slice(0,2);
  return _voices.find(v=>v.lang===bcp)
      || _voices.find(v=>v.lang.startsWith(px)&&v.localService)
      || _voices.find(v=>v.lang.startsWith(px))
      || null;
}

// â”€â”€ SPEAK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DEVE essere chiamato dentro un evento STT o click diretto
function speakNow(text, lang, btnId){
  if(!window.speechSynthesis || !text) return;
  speechSynthesis.cancel();
  const u    = new SpeechSynthesisUtterance(text);
  u.lang     = BCP[lang]||'en-US';
  u.rate     = 0.88; u.pitch = 1;
  u.voice    = getVoice(lang);
  const btn  = $(btnId);
  if(btn) btn.classList.add('tts');
  const done = () => { if(btn) btn.classList.remove('tts'); };
  u.onend = done; u.onerror = done;
  // Fix iOS pausa spontanea
  const fix = setInterval(()=>{ if(!speechSynthesis.speaking){clearInterval(fix);return;} if(speechSynthesis.paused) speechSynthesis.resume(); },300);
  u.onend = ()=>{ clearInterval(fix); done(); };
  u.onerror = ()=>{ clearInterval(fix); done(); };
  speechSynthesis.speak(u);
}

// â”€â”€ TRADUZIONE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function doTranslate(text, from, to){
  if(!text||from===to) return text;
  try{
    const r = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${from}|${to}`);
    const d = await r.json();
    if(d.responseStatus===200&&d.responseData?.translatedText){
      const t=d.responseData.translatedText;
      if(t&&!t.includes('MYMEMORY WARNING')&&t.toLowerCase()!==text.toLowerCase()) return t;
    }
  }catch(e){}
  return text;
}

// â”€â”€ STATO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let rec=null, rSide=null, rTimer=null, rSec=0, rFinal='';
let translationReady = null; // Promise della traduzione, lanciata subito
const MAX = 12;

function tap(side){
  if(rSide===side){ forceStop(); return; }
  if(rSide) cancelRec();
  startRec(side);
}

function startRec(side){
  const SR = window.SpeechRecognition||window.webkitSpeechRecognition;
  if(!SR){ toast('Usa Safari su iPhone o Chrome su Android'); return; }

  const lang=gl(side);
  rSide=side; rFinal=''; translationReady=null;

  const btn=$('b'+side), ta=$('t'+side), tmr=$('m'+side), ring=$('r'+side);
  const lbl=side==='a'?$('nla'):$('nlb');
  btn.classList.add('rec');
  lbl.textContent='â¹';
  ta.className='txt on'; ta.textContent='ğŸ™ï¸ â€¦';
  tmr.textContent='';

  rSec=MAX; const C=314;
  ring.style.strokeDashoffset=C;
  rTimer=setInterval(()=>{
    rSec--; tmr.textContent=rSec+'s';
    ring.style.strokeDashoffset=C-((MAX-rSec)/MAX)*C;
    if(rSec<=0) forceStop();
  },1000);

  rec=new SR();
  rec.lang=BCP[lang]||'en-US';
  rec.interimResults=true;
  rec.continuous=false; // auto-stop sul silenzio

  const other=side==='a'?'b':'a';
  const toLang=gl(other);

  rec.onresult=e=>{
    rFinal=''; let tmp='';
    for(let i=0;i<e.results.length;i++){
      if(e.results[i].isFinal) rFinal+=e.results[i][0].transcript+' ';
      else tmp+=e.results[i][0].transcript;
    }
    const disp=(rFinal+tmp).trim();
    ta.textContent=disp||'ğŸ™ï¸ â€¦';
    // Avvia traduzione NON APPENA arriva il testo finale
    // cosÃ¬ quando onend scatta, potrebbe essere giÃ  pronta
    if(rFinal.trim() && !translationReady){
      translationReady = doTranslate(rFinal.trim(), lang, toLang);
    }
  };

  rec.onerror=e=>{
    if(e.error==='no-speech'){ onRecEnd(side, lang, other, toLang); return; }
    if(e.error!=='aborted') toast('âŒ '+e.error);
    cancelRec();
  };

  // â˜… KEY: onend Ã¨ considerato "user-initiated" da iOS Safari
  // Possiamo chiamare speak() qui dentro!
  rec.onend=()=>{ if(rSide===side) onRecEnd(side, lang, other, toLang); };

  try{ rec.start(); }
  catch(e){ toast('âŒ Microfono non disponibile'); cancelRec(); }
}

// Chiamato dentro rec.onend â€” evento STT = user-initiated su iOS!
function onRecEnd(side, lang, other, toLang){
  const text = rFinal.trim();
  resetUI(side);

  const ta=$('t'+side);
  if(!text){ ta.className='txt ph'; ta.textContent='â€¦'; return; }
  ta.className='txt'; ta.textContent=text;

  const oTA=$('t'+other), oSt=$('s'+other);
  oTA.className='txt'; oTA.textContent='â€¦';
  oSt.innerHTML='<div class="spin"></div>';

  // Se la traduzione Ã¨ giÃ  pronta (Promise resolved), usa quella.
  // Altrimenti aspetta â€” ma siamo ancora nel "contesto" dell'evento STT
  // quindi speak() funzionerÃ .
  if(translationReady){
    translationReady.then(out => {
      oSt.innerHTML='';
      const final=out||text;
      oTA.className='txt say'; oTA.textContent=final;
      // speak() dentro .then() di una Promise avviata in onend â†’ iOS OK
      speakNow(final, toLang, 'b'+other);
    });
  } else {
    // Nessun testo riconosciuto â€” mostra originale
    oSt.innerHTML='';
    oTA.className='txt say'; oTA.textContent=text;
    speakNow(text, toLang, 'b'+other);
  }
}

function forceStop(){
  if(!rSide) return;
  // Ferma la recognition â€” scatterÃ  onend â†’ onRecEnd
  if(rec){ try{ rec.stop(); }catch(e){ onRecEnd(rSide, gl(rSide), rSide==='a'?'b':'a', gl(rSide==='a'?'b':'a')); } }
}

function cancelRec(){ if(rec){try{rec.abort();}catch(e){}} resetUI(rSide); }

function resetUI(side){
  clearInterval(rTimer); rTimer=null;
  if(rec){try{rec.abort();}catch(e){} rec=null;}
  if(!side) return;
  const lbl=side==='a'?$('nla'):$('nlb');
  $('b'+side).classList.remove('rec','tts');
  lbl.textContent=LBL[gl(side)]||'Speak';
  $('m'+side).textContent='';
  $('r'+side).style.strokeDashoffset='314';
  $('t'+side).classList.remove('on');
  rSide=null;
}

document.addEventListener('DOMContentLoaded',()=>{ onLC('a'); onLC('b'); loadVoices(); });
</script>
</body>
</html>
